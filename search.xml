<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工作记录[2]</title>
      <link href="/2024/12/26/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%952/"/>
      <url>/2024/12/26/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<h1 id="工作记录2"><a href="#工作记录2" class="headerlink" title="工作记录2"></a>工作记录2</h1><p>鉴于之前已经将基于mailbox的连接跑通，虽然对mailbox的一些设计还是没有特别理解，但还是打算先写一些初步的测试代码，以验证其部分功能的正确性。</p><p>或许写着写着就能龙场悟道。</p><h2 id="测试程序设计"><a href="#测试程序设计" class="headerlink" title="测试程序设计"></a>测试程序设计</h2><p>测试程序为mbx_test.c，该程序被编译成的bin文件会被加载到CPU的内存中被执行。</p><p>首先先输出一行测试开始的信息，再定义要用到的寄存器的的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOG_INFO(<span class="string">&quot;MBX TEST BEGINS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *mailbox0_base_addr = (<span class="type">void</span>*)<span class="number">0x3b100000</span>;</span><br><span class="line"><span class="type">void</span> *mailbox0_control_addr = (<span class="type">void</span>*)<span class="number">0x3b100008</span>;</span><br><span class="line"><span class="type">void</span> *mailbox0_status_addr = (<span class="type">void</span>*)<span class="number">0x3b10000c</span>;</span><br><span class="line"><span class="type">void</span> *mailbox0_wdata_addr = (<span class="type">void</span>*)<span class="number">0x3b100010</span>;</span><br><span class="line"><span class="type">void</span> *mailbox0_rdata_addr = (<span class="type">void</span>*)<span class="number">0x3b100014</span>;</span><br></pre></td></tr></table></figure><p>紧接着卡住了。原以为可以通过邮箱向OT RoT内存中写东西，但现在发现不行。所有RoT的内存空间传输数据的行为都需要通过DMA，这包括：</p><ol><li>简单的DMA传输请求：<ul><li>说明：请求者根据DMA传输操作的要求指定源地址、目标地址、源空间ID和目标空间ID。集成的OpenTitan主机固件解析对象，检查请求，如果认为传输可以进行，则配置OT DMA控制器。</li><li>响应对象：预期有响应DOE对象</li><li>中断：如果启用，可以配置在DMA传输完成后向请求者生成中断。</li></ul></li><li>安全存储写入代理<ul><li>说明：由请求者（系统主机或SoC固件元素）使用，以请求OT RoT提供对OT RoT拥有的闪存存储的代理访问。要写入闪存的内容<strong>由请求者放置在SoC内存位置</strong>中，并通过DOE对象传递写入请求和内存指针。响应者执行安全检查，启<strong>动内容到闪存的DMA传输</strong>，并完成闪存写入操作。</li><li>请求者在请求对象中设置以下参数：<ol><li>目标地址：指向从中读取数据的闪存存储地址的指针</li><li>目标地址ID：&#x3D; 0x3（FLASH）</li><li>源地址：放置NV存储（Non-Volatile Storage，非易失性存储）读取数据的内存位置</li><li>源地址ID：根据请求者要求，为系统内存或CTN内存</li><li>总大小：要写入的数据块的大小</li></ol></li><li>如果OT的策略允许写入闪存的该部分，OT将启动写入访问。</li></ul></li></ol><p>然而，我在曾经对整体架构理解很浅时，写出的连接的代码中DMA连接部分是错误的。在上一次的源代码更改中，我将DMA对应的TL node（主端）从blackbox中删去了。这导致目前只支持mailbox访问，而mailbox访问的主要目的——使用DMA传输数据，则完全无法实现。</p><p>没办法，要么先正确连上DMA，要么先测试mailbox的少部分功能。我选择先执行后者？原因有二，一来是先确保一部分功能的正确性，后续debug时能更加容易推出出问题的地方，二来是很快要开组会了，得有点东西好讲。</p><p>首先，先把支持读的邮箱寄存器都读一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">uint32_t</span> ref_control = <span class="number">0xffffffff</span>;</span><br><span class="line">   <span class="type">uint32_t</span> ref_status = <span class="number">0xffffffff</span>;</span><br><span class="line">   <span class="type">uint32_t</span> ref_wdata = <span class="number">0xffffffff</span>;</span><br><span class="line">   <span class="type">uint32_t</span> ref_rdata = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">ref_control = *(<span class="type">uint32_t</span>*)mailbox0_control_addr;</span><br><span class="line">   LOG_INFO(<span class="string">&quot;READ SUCCESSFULLY! ref_control == %X&quot;</span>, ref_control);</span><br><span class="line">   ref_status = *(<span class="type">uint32_t</span>*)mailbox0_status_addr;</span><br><span class="line">   LOG_INFO(<span class="string">&quot;READ SUCCESSFULLY! ref_status == %X&quot;</span>, ref_status);</span><br><span class="line">   ref_wdata = *(<span class="type">uint32_t</span>*)mailbox0_wdata_addr;</span><br><span class="line">   LOG_INFO(<span class="string">&quot;READ SUCCESSFULLY! ref_wdata == %X&quot;</span>, ref_wdata);</span><br><span class="line">   ref_rdata = *(<span class="type">uint32_t</span>*)mailbox0_rdata_addr;</span><br><span class="line">   LOG_INFO(<span class="string">&quot;READ SUCCESSFULLY! ref_rdata == %X&quot;</span>, ref_rdata);</span><br></pre></td></tr></table></figure><p>编译测试了一下，很快得到了结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I00000 ./src/sw/device/tests/mbx_test.c:11] MBX TEST BEGINS</span><br><span class="line">I00001 ./src/sw/device/tests/mbx_test.c:24] READ SUCCESSFULLY! ref_control == 0</span><br><span class="line">I00002 ./src/sw/device/tests/mbx_test.c:26] READ SUCCESSFULLY! ref_status == 1</span><br><span class="line">I00003 ./src/sw/device/tests/mbx_test.c:28] READ SUCCESSFULLY! ref_wdata == 0</span><br><span class="line">I00004 ./src/sw/device/tests/mbx_test.c:30] READ SUCCESSFULLY! ref_rdata == 0</span><br></pre></td></tr></table></figure><p>很奇怪，为什么status的第0位，即DOE Busy是1？文档中提到，此位由DOE实例在处理接收到的数据对象时设置，但现在明明没有在处理什么事务啊。</p><p>略微修改代码，结果：</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/3-1.png" style="zoom: 40%;" /><p>……肯定哪里出问题了。查询mbx_reg_pkg.sv：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] MBX_STATUS_RESVAL = <span class="number">4</span>&#x27;h <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>status寄存器的初始值被设为1。<strong>即在复位时，DOE Busy位确实是被设为了1</strong>？</p><p>但要如何将这一位变为0？一种情况是处理完数据对象，但我并没有往里传数据对象；另一种是处理完Abort，但我更没有给出abort指令。那在这种情况下，他自己又似乎不会无缘无故将busy位设为0，那难道要我给出abort指令？或者我手动将其改为0？</p><h2 id="关于DOE-busy复位后为1"><a href="#关于DOE-busy复位后为1" class="headerlink" title="关于DOE busy复位后为1"></a>关于DOE busy复位后为1</h2><p>没找到相关文档，所以首先，我决定看波形。</p><p>唉，我是真不想看波形，有种吸一口气然后深潜的感觉。</p><p>一番找寻后，终于发现问题所在——在mbx_imbx.sv中，hostif_range_valid_i这个信号是拉低的。这应该是我没设置好base_address和limit_address导致的。</p><p>关于以上两个参数（实际上是四个，入站和出站各两个），文档中对其解释为（对于imbx）：</p><ul><li>base_address：标记 OT 内部内存空间中启用内存范围起始的基地址。</li><li>limit_address：标记 OT 内部内存空间中 DOE 收件箱内存范围结束的限制。</li><li>那么为什么之前没设置呢？因为文档里很明确说明SoC通过4个邮箱寄存器与RoT交互。而imbx和ombx的base_address寄存器和limit_address寄存器并不属于这4个邮箱，它们是OpenTitan Internal DOE Registers。即<strong>外部无法访问</strong>，只能被内部的固件访问（these registers are accessible to the firmware running on IBEX core only）。</li></ul><p>翻阅源代码，发现其确实是只能被来自core的tl信号更改，<strong>来自SoC的tl信号无法访问这些寄存器</strong>（测试过了）。</p><p>所以这样就陷入死锁了。我首先想到，是不是应该<strong>在RoT的ROM里的boot程序里加东西或者改参数</strong>，但看半天相关文档发现显然不太行。</p><p>然后我就想干脆把mbx和ombx的base_address和limit_address的复位值改了，使其符合要求不就行了吗。虽然这种做法显然非常有问题，但我一时想不到别的方法。但在改完之后，我发现<strong>即使这些值都被正确设置了，但range valid仍为0</strong>。</p><p>我认为这可能说明<strong>range valid不是通过硬件判断的</strong>。翻源代码发现确实如此，<strong>是来自core的tl信号控制写入的</strong>。那这样的话我干脆把range valid的复位值也改为1。虽然这样做问题显然更大了，但我想不到别的办法。但这样设置后，其mailbox中的range valid仍然为0。这是因为<strong>判断该valid还需要一个enable信号，这个信号在来自core的tl信号往valid里写入0或1时被拉高</strong>。</p><p>所以现在又回到了前面的问题。翻阅各个文档完全没有提到这种情况。</p><p>后面发现Darjeeling的文档中有提到这么一句：</p><blockquote><p>Communication with the SoC is mainly via the mailboxes, DMA and SoC proxy module. The SoC proxy module serves as a comportable IP frontend for incoming IRQs, reset requests, <strong>wake up requests</strong>, alerts and the TL-UL egress port into the CTN network.</p></blockquote><p>之前一直只关注mailbox和DMA，而一直忽略了SoC proxy module。这里提到说，这个代理模块处理wake up requests。我查看SoC proxy 的文档，但里面没有对这个代理模块的任何解释。所以我决定先在源代码里找到这个异步唤醒请求信号。</p><p>Darjeeling的官方有给出一个chip_darjeeling_verilator.sv，其中实例化了top_darjeeling，用于进行一些模块的简单测试。我找到该端口，发现：</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/3-2.png" style="zoom:80%;" /><p>也就是说，<strong>SoC应该负责给出这个“唤醒请求”，但以前是认为RoT在被复位后即可直接使用</strong>，我认为这二者是冲突的。我不知道这个请求是干嘛的，也不知道其输入的时序逻辑应该是怎样的（因为没有文档，我猜起码要拉高一段时间），但我猜测需要给出这个请求，RoT才能进入“工作状态”，然后core会配置好mailbox的一些只能由内部core访问的参数寄存器。</p><p>所以现在的想法是，<strong>在复位完成后拉高一段时间这个信号，然后再进行测试</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作记录[1]</title>
      <link href="/2024/12/14/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%951/"/>
      <url>/2024/12/14/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<h1 id="工作记录-1"><a href="#工作记录-1" class="headerlink" title="工作记录[1]"></a>工作记录[1]</h1><p>为了防止未来的我忘记现在的我在想什么，同时也可以水一些博客，打算写写工作记录。</p><p>这些记录对绝大部分情况下的绝大部分人应该都没有什么参考价值。</p><h2 id="Darjeeling中的Mailbox"><a href="#Darjeeling中的Mailbox" class="headerlink" title="Darjeeling中的Mailbox"></a>Darjeeling中的Mailbox</h2><p>（对于mailbox0）</p><ul><li><p>参考mbx_reg_pkg.sv中的代码：</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register offsets for soc interface</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_SOC_CONTROL_OFFSET = <span class="number">5</span>&#x27;h <span class="number">8</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_SOC_STATUS_OFFSET = <span class="number">5</span>&#x27;h c;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_SOC_DOE_INTR_MSG_ADDR_OFFSET = <span class="number">5</span>&#x27;h <span class="number">18</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_SOC_DOE_INTR_MSG_DATA_OFFSET = <span class="number">5</span>&#x27;h <span class="number">1</span>c;</span><br></pre></td></tr></table></figure></li><li><p>基地址：0，我在配置地址（在tl_mbx_pkg.sv中）时将其映射至0x3b100000。</p></li><li><p>该邮箱不支持PCIe拓展，而所有邮箱（普通mailbox和mailbox_pcie）都是用一个同模块实例化的。故对于mailbox0，0~7的地址内（原本是DOE Extended Capability Header和DOE Capability Header）是无用的。</p></li><li><p>DOE Interrupt Message Address Register：</p><ul><li>仅在固件与固件之间的邮箱通信情况下定义。由邮箱响应方通过写入已配置的地址向请求方发送中断消息。需要注意的是，这种固件到固件的邮箱可能主要在CTN地址空间中可访问。因此，配置的地址属于SoC的CTN地址空间的一部分。</li><li>CPU执行指令访问邮箱并不属于固件与固件之间的邮箱通信，算是<strong>软件驱动的通信</strong>。故其对应地址空间也是无用的。</li><li>映射后地址为0x3b100018。</li></ul></li><li><p>DOE Interrupt Message Data Register：</p><ul><li>要发送到 DOE 中断消息地址寄存器中配置的地址的中断消息数据</li><li>映射后地址为0x3b10001c。</li></ul></li><li><p>以上四个寄存器暂时都不在考虑范围内。</p></li><li><p><strong>DOE Control Register：</strong></p><ul><li><p>DOE控制寄存器</p></li><li><table><thead><tr><th>位位置</th><th>位定义</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>DOE中止（DOE Abort）</td><td>当向此字段中写入1’b1时，中止所有数据对象传输操作。读取此字段始终返回0。</td></tr><tr><td>1</td><td>DOE中断使能（DOE Interrupt Enable）</td><td>设置时，DOE实例被允许发送中断。</td></tr><tr><td>2</td><td>待定</td><td></td></tr><tr><td>3</td><td>DOE异步消息使能（DOE Async Message Enable）</td><td>使响应者可以向请求者发送异步消息</td></tr><tr><td>4:30</td><td>保留</td><td></td></tr><tr><td>31</td><td>DOE启动（DOE Go）</td><td>表示通过DOE写数据邮箱寄存器传输的DOE对象已准备好被使用。<br />在<strong>传输整个对象之前</strong>设置Go位的行为是未定义的。<br />在<strong>DOE忙位被置位时</strong>设置Go位的行为是未定义的。<br />读取此位始终返回零。</td></tr></tbody></table></li><li><p>映射地址为0x3b10000c。</p></li></ul></li><li><p><strong>DOE Status Register</strong></p><ul><li><p>DOE状态寄存器</p></li><li><table><thead><tr><th>位位置</th><th>位定义</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>DOE忙（DOE Busy）</td><td>当DOE实例正在处理接收到的数据对象时，此位被设置。<br />设置时表示DOE实例正忙，无法通过DOE写数据邮箱寄存器接受新的数据对象。<br />在处理中止命令时，DOE实例必须设置此位，中止处理完成后清除。</td></tr><tr><td>1</td><td>DOE中断状态（DOE Interrupt Status）</td><td>如果启用中断，则生成中断以指示数据对象（响应）已准备好供请求者使用，或DOE错误已设置，或DOE忙位已清除（即准备接受新对象）。<br />当断言此类中断时，此位被设置。<br />向此位写入值1会清除状态位。</td></tr><tr><td>2</td><td>DOE错误（DOE Error）</td><td>如果处理接收到的数据对象时发生内部错误或遇到不支持的数据对象，DOE实例设置此位。<br />通过向DOE控制寄存器中的DOE终止位写入1’b1来清除此位。<br />DOE中止是清除此位的唯一机制。</td></tr><tr><td>3</td><td>DOE异步消息状态（DOE Async Message Status）</td><td>当有一个或多个异步消息准备传输给请求者时，由响应者设置</td></tr><tr><td>4</td><td>待定</td><td></td></tr><tr><td>5:30</td><td>保留</td><td></td></tr><tr><td>31</td><td>DOE对象就绪（DOE Object Ready）</td><td>表示DOE对象（响应）已准备好通过DOE读数据邮箱寄存器被系统主机读取。一旦系统软件读取整个数据对象且没有更多对象准备传输，DOE实例应清除此位。如果尚未清除，DOE实例应在响应DOE中止处理时清除此位。<br />读取此位始终返回0（？为什么？）。默认值为0。</td></tr></tbody></table></li><li><p>映射地址为0x3b100008。</p></li></ul></li><li><p>同样参考mbx_reg_pkg.sv中的代码：</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Window parameters for soc interface</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_WDATA_OFFSET = <span class="number">5</span>&#x27;h <span class="number">10</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">int</span> <span class="keyword">unsigned</span>      MBX_WDATA_SIZE   = &#x27;h <span class="number">4</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">int</span> <span class="keyword">unsigned</span>      MBX_WDATA_IDX    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">logic</span> [SocAw-<span class="number">1</span>:<span class="number">0</span>] MBX_RDATA_OFFSET = <span class="number">5</span>&#x27;h <span class="number">14</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">int</span> <span class="keyword">unsigned</span>      MBX_RDATA_SIZE   = &#x27;h <span class="number">4</span>;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">int</span> <span class="keyword">unsigned</span>      MBX_RDATA_IDX    = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>DOE Write Data Mailbox Register</strong></p><ul><li>DOE写数据邮箱寄存器</li><li>32位</li><li>DOE 写数据双字：<ul><li>通过每次向此寄存器写入一个双字来将 DOE 对象传输到 DOE 实例。</li><li>成功写入会向 DOE 实例中正在组装的数据对象添加一个双字。</li><li>向 DOE 控制寄存器中的 DOE Go 位写入 1’b1 标志着数据传输的完成，即对象的最后一个双字已被写入。</li></ul></li><li>映射地址为0x3b100010</li></ul></li><li><p><strong>DOE Read Data Mailbox Register</strong></p><ul><li>DOE读数据邮箱寄存器</li><li>32位</li><li>DOE 读数据双字：<ul><li><strong>一旦 DOE 实例在 DOE 状态寄存器中设置了 DOE 对象就绪位</strong>，系统软件就可以通过每次读取此寄存器一个双字（DWORD）来从 DOE 实例读取 DOE 对象。</li><li><strong>向此寄存器写入任何值表示成功读取当前双字</strong>。随后对此寄存器的读取将返回正在读取的数据对象中的下一个双字。</li><li>当 DOE 对象就绪位（<strong>DOE Status Register</strong>的31位）被设置时，可以连续传输数据对象。如果 DOE 数据对象就绪位被清除，向此寄存器写入任何值都不应产生效果，且从此寄存器读取必须返回零。</li></ul></li><li>映射地址为0x3b100014</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么mailbox的DOE状态寄存器的DOE对象就绪（DOE Object Ready）位在被读取时始终返回0？这样的话系统主机端怎么知道DOE响应是否就绪，以及现在从DOE读数据寄存器读出来的东西是否是DOE响应的一部分？虽然应该也可以通过DOE中断状态位来判断，但如果没启用中断怎么办。而且中断状态位是由系统主机置0的，那系统主机要怎么知道一个响应被读取完了没有？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建我的个人博客</title>
      <link href="/2024/12/08/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/12/08/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建我的个人博客"><a href="#搭建我的个人博客" class="headerlink" title="搭建我的个人博客"></a>搭建我的个人博客</h1><h2 id="前言——一些啰嗦的随想"><a href="#前言——一些啰嗦的随想" class="headerlink" title="前言——一些啰嗦的随想"></a>前言——一些啰嗦的随想</h2><p>现在是2024年12月7日凌晨0点21分，我正坐在机电楼806实验室的工位上，准备继续搭建自己的个人博客。</p><p>说是“继续”搭建，其实之前除了部署了一个模板网页，也没做什么。虽然很早就想做这件事，但总是忙于别的事。<del>其实很多时候也不忙，但那些时候我又是单纯的懒。</del></p><p>点的奶茶送到了，先去取外卖了。一会接着写。 </p><p><em>（大约十分钟后）</em></p><p>回到工位了。想到博客应该加点配图，遂给奶茶拍了张照。</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-1.jpg" style="zoom: 12%;" /><p>奶茶的颜色比我想的要深，我看奶茶名字还以为会是粉色的。不过比起粉色还是这样的颜色更让人有食欲。</p><p>后面的保温杯里泡的是前段时间买的金银花菊花决明子牛蒡茶。但显然我更喜欢喝奶茶，就算它又贵（对我来说）又不健康（老生常谈），但它好喝，这就抵得上很多了。 </p><p>现在应该开工了，但我想先写点随想。虽然这应该是篇经验贴，写太多随想会弄得很啰嗦。但这是我自己的博客，我爱咋写咋写。</p><p>耳机在播放网易云随机推荐的歌，现在这首叫《Young And Beautiful》，是《了不起的盖茨比》的配乐。我没看过这部电影，虽然我看过它的解读文章（在豆瓣和知乎上）、看过它的解说视频（“老X侃电影”那种解说），但我没看过它的电影原作。也许等到什么时候心血来潮会看吧。</p><p>突然想到第一次知道这部电影，是在江南的某本书里。应该是《龙族》的某一部？说起来我以前是真喜欢龙族啊。你能想到一个天天看《斗破苍穹》、《斗罗大陆》、《吞噬星空》的小孩第一次看龙族时的震撼吗？其他的网文小说还在平铺直叙的时候，江南的描写却给我一种像在电影院看电影一样的身临其境的感觉，关键是这电影还帅得没边。当时先看了一部分第二部，就好像天天吃辣条的小孩突然有一天尝到了德芙。之后很快把一到三部都看完了，看完后又反反复复看了好多遍。那时真觉得楚子航是这个世界最帅的男人吧，同时也觉得江南的文笔真是天下无匹。语文课上天天赏析的世界名著？无聊、枯燥、老套、看了想睡觉，感觉都不如一场雨落狂流之暗或是一次迎着阳光盛大逃亡。</p><p>成为一个没那么二次元的二次元，一部分也是因为龙族这小说。很早以前，除了名侦探柯南、蜡笔小新、龙珠这类动漫，我也没怎么看过其他能称为“二次元”的作品。后来好像是在乐视视频，不知道怎么就点进一部叫作《人形电脑天使心》的动漫。这动漫也挺老的了，也不知道它评价怎么样，起码当时给我感动得不行。后面也没看其他动漫。再后来看了龙族，里面提到凉宫春日。出于好奇我就去看了——真好看吧！于是直接一口气把全系列都看了（除了漫无止境的夏日那块被我给跳过了）。当时真喜欢长门有希啊，也真喜欢朝比奈学姐。不过我那时不怎么喜欢凉宫春日，她老是欺负人，也过于任性了（起码当时是这么想的，现在剧情也忘得七七八八了）。从这以后就常常看番了——刀剑神域（我简直是男主）、约会大作战（我为什么不是男主）、未闻花名（哭得最惨的一次，不过后面被朝花夕誓抢走了这一荣誉）、叛逆的鲁鲁修（我不如男主）……</p><p>奶茶味道很一般，不是很推荐大家买这款。</p><p>好了，该开工了。</p><p><del>这时dmx和ckk突然说要走了，遂回宿舍。明天继续做吧。</del></p><h2 id="照虎画猫——笨拙地模仿"><a href="#照虎画猫——笨拙地模仿" class="headerlink" title="照虎画猫——笨拙地模仿"></a>照虎画猫——笨拙地模仿</h2><p>我本人完全没有搭建博客方面的经验，遂上网找了一篇看着还不错的<a href="https://www.cnblogs.com/coder-Jason/p/15821938.html">教程</a>作为参考资料。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>依照教程，我选择<a href="https://www.jetbrains.com/webstorm/">WebStorm</a>作为开发工具。据说这款IDE被称为誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”……不过我并没有什么Web前端开发的经验，说什么我都信。</p><p>教程中也提到可以安装<a href="https://code.visualstudio.com/">VSCode</a>作为IDE。感觉写代码的大伙电脑里基本都有这个？尤其是主要开发环境在Windows下的。不过鉴于WebStorm是全家桶，而VSCode还需要自己去配置，我还是选择WebStorm。</p><p>至于写Markdown，我选择的是<a href="https://typoraio.cn/">Typora</a>。正版收费，不过89元买断制也完全可以接受。其实直接在VSCode上装个Markdown插件就已经可以支持这个需求了。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>我完全不打算从零开始写一个自己的网页，所以我打算使用已有的博客框架。</p><blockquote><p>博客框架通俗的说就是别人写好的一套源码，你拿过来会用就行，改一改自己的配置啊，配上想要的主题啊，这种就足够了（大佬请绕路）。</p></blockquote><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p><a href="https://hexo.io/zh-cn/index.html">Hexo</a>是一个快速、简单且功能强大的博客框架。依据参考文章的推荐，加上我自己看了看觉得也挺不错的，我决定选择该框架。</p><h4 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h4><p>文章中也提到<a href="https://cn.wordpress.org/">WordPress</a>。虽然这个框架的功能也很强大，但使用它的前提是有一台服务器。我暂时没有租一台服务器的打算。</p><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><p>Hexo这样的框架只是原材料，而我们需要“工具”来处理使用材料。</p><h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><p><a href="https://git-scm.com/">git</a>相信大家都不陌生了，至少也有听说了解过。关于它的作用、安装教程和使用教程，网络上数不胜数。在此不做赘述。</p><h4 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h4><p><a href="https://nodejs.org/en/">Node.js</a>是一个开源的、跨平台的、基于JavaScript的运行时环境，主要用于构建高性能的服务器端和网络应用。它是由Ryan Dahl在2009年创建的，并基于Google的V8 JavaScript引擎运行。Node.js的出现使得开发者可以使用JavaScript不仅在浏览器端进行开发，还可以在服务器端构建高效的应用程序。</p><p>老实说我不是很懂这些。但既然需要用到，就装上吧。</p><p>其中有LTS（Long Term Support，长期支持）版和Current版（最新版）。我们选择LTS版。</p><h3 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我们可以直接在桌面右键打开git bash，输入命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，本地就已经有了Hexo环境。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在本地任意路径下新建一个文件夹，在其中打开git bash，输入命令初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>可能会遇到些问题？有遇到可以试试参考<a href="https://www.cnblogs.com/fairylyl/p/15059437.html">这篇文章</a>。我并未在此遇到问题。</p><p>成功后该目录下文件和文件夹如下：</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-2.png" style="zoom:50%;" /><p>Hexo大致文件结构：</p><ul><li>public：最终所见网页的所有内容</li><li>node_modules：插件以及hexo所需node.js模块</li><li>_config.yml：站点配置文件，设定一些公开信息等</li><li>package.json：应用程序信息，配置hexo运行所需js包</li><li>scaffolds：模板文件夹，新建文章，会默认包含对应模板内容</li><li>themes：存放主题文件，hexo根据主题生成静态网页</li><li>source：用于存放用户资源（除 <em>posts 文件夹，其余命名方式为 “</em> + 文件名”的文件被忽略）</li></ul><p>我们平时写的Markdown格式文章都在source&#x2F;_post下。</p><p>现在，我们可以使用WebStorm打开该项目了。</p><p>在WebStorm中打开终端，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>效果如下（此处已经设置了butterfly主题，输出与默认主题不太一样）：</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-3.png" style="zoom:50%;" /><p>此时我们可以用浏览器访问本地的4000端口来预览我们的主页了。</p><p>我们使用浏览器访问<a href="http://127.0.0.1:4000/">127.0.0.1:4000</a>或<a href="http://localhost:4000/">localhost:4000</a>即可。</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-4.png" style="zoom: 25%;" /><p>至此，我们就得到了一个预制的毛坯房。</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>在该框架下，有相当多的主题可以挑选。就好像大伙都比较熟悉的手机的各种主题——图标、背景、字体等。</p><p>我们可以在<a href="https://hexo.io/themes/">官方主题库</a>中选择自己喜欢的主题。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>我们在此以<em>Butterfly</em>主题为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>等待安装完成，themes文件夹下会显示butterfly主题的一些文件</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-5.png" style="zoom:50%;" /><p>接着我们需要安装其所需的插件，即pug以及stylus的渲染器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>安装完成后，我们需要修改网站配置文件，以使其使用该主题。我们在网站的根目录下找到_config.yml文件，修改主题为butterfly。</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-6.png" style="zoom: 33%;" /><p>接着我们可以开始本地预览了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g //生成博客目录</span><br><span class="line">hexo s //本地预览</span><br></pre></td></tr></table></figure><p>此时我们的网页可能还略显简陋。大家可以在后续对其进行美化。</p><h3 id="正式上线"><a href="#正式上线" class="headerlink" title="正式上线"></a>正式上线</h3><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>加速图片加载用的。还没搞这个，先略过。</p><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>Butterfly主题的<a href="https://butterfly.js.org/posts/4aa8abbe/">官方文档</a>附在此处。可以根据该文档进行设置。</p><h4 id="Github-Pages配置"><a href="#Github-Pages配置" class="headerlink" title="Github Pages配置"></a>Github Pages配置</h4><p>GitHub Pages是一种由GitHub中的仓库&#x2F;项目直接创建的网页，管理简单。在本地编辑仓库中的内容，上传到GitHub上，GitHub Pages就能快速完成更新。而这一切都是完全免费的。</p><p>我们在GitHub中新建仓库，</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-7.png" style="zoom:25%;" /><p>接着，我们在仓库的设置中找到Pages</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-8.png" style="zoom:25%;" /><p>记住仓库地址，我们会将本地的文件上传到仓库。</p><p>如果你没有配置公钥，可以先配置SSH公钥。可以直接搜索“GitHub SSH公钥”以查找教程。</p><p>我们在WebStorm中链接到远程。添加仓库地址。</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-9.png" style="zoom: 33%;" /><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-10.png" style="zoom:33%;" /><p>接着，我们修改网站部署设置。</p><img src="https://solomaple-1333073384.cos.ap-beijing.myqcloud.com/1-11.png" style="zoom:33%;" /><p>接着，我们在中端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g //生成博客目录</span><br><span class="line">hexo s //本地预览，确认效果</span><br><span class="line">hexo d //部署项目</span><br></pre></td></tr></table></figure><p>执行完毕后，就可以通过<strong>用户名.github.io</strong>访问我们的个人主页了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>你还可以为你的个人主页配置图床、租一台服务器，或是买一个域名。但我暂时并未有这些打算，该博客的经验记录也就到此结束了。</p><h2 id="写在后面——人生总是这样"><a href="#写在后面——人生总是这样" class="headerlink" title="写在后面——人生总是这样"></a>写在后面——人生总是这样</h2><p>“人生总是这样”，这是我最近经常说的一句话。</p><p>有时有人向我倾诉或者倾泻了一大堆话，接着等我的“读后感”，这时我我可能就会回复“人生总是这样”。</p><p>其实我对“单方面向我输出一大堆话”这件事完全没有什么意见，我也挺喜欢听别人说话的。但我的头脑转得不够快，脑中所容纳的知识储备也并不多。所以在对方讲完之后，如果我的脑中没能生成出合适的答复（这概率并不低），而对方又在用沉默来期盼我的回应，我就会回一句“人生总是这样”。</p><p>前面写了这么多，大抵是需要一片后记作总结的。</p><p>但是啊，我不知道该写些什么。</p><p>所以说啊，人生总是这样……</p><p>2024年12月8日2时39分</p>]]></content>
      
      
      
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>About Me</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><strong>你好 👋，我是</strong> <span style="font-size: 20px; font-weight: bold; color: #333; font-family: 'Brush Script MT', cursive;">SoloMaple</span></p><p>🧑 来自浙江省丽水市缙云县，现在是一名计算机科学与技术专业的大四学生<br>🌟 在计算机领域兴趣广泛，在偏硬件（如处理器架构）相关方向学得较多<br>💻 研究生方向是计算机系统结构<br>📺 喜欢看动漫、听歌、看剧、看小说<br>🎮 当然也是游戏爱好者，各类游戏都有涉猎<br>🌌 我的性格（以MBTI角度）：INTJ-T<br>📧 联系我：maple.dzf@qq.com<br>🌱 还有很多想做的事……</p><p><strong>我的足迹</strong><br>✨ 浙江省缙云县实验小学<br>✨ 浙江省缙云县实验中学<br>✨ 浙江省缙云中学，纯种理科生<br>✨ 北京科技大学，高等工程师学院，计算机科学与技术<br>✨ ……</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签索引</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的朋友们</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
